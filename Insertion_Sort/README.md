# :collision: الگوریتم Insertion Sort

الگوریتم Insertion Sort یکی از ساده‌ترین و در عین حال کارآمدترین الگوریتم‌های مرتب‌سازی است که به خصوص برای لیست‌های کوچک و تقریباً مرتب، بسیار مؤثر است. این الگوریتم به روش "مرتب‌سازی درجی" (in-place) عمل می‌کند، به این معنی که نیاز به فضای اضافی زیادی ندارد. در اینجا به توضیح کامل الگوریتم Insertion Sort و نحوه عملکرد آن می‌پردازیم.

## نحوه عملکرد الگوریتم Insertion Sort

الگوریتم Insertion Sort به این صورت عمل می‌کند که به طور مکرر عناصر یک آرایه را به صورت یک به یک از آرایه می‌گیرد و در موقعیت صحیح خود در بخش مرتب‌شده آرایه قرار می‌دهد. در ادامه مراحل این الگوریتم را به طور دقیق توضیح می‌دهیم:

1. **شروع از دومین عنصر**: فرض می‌شود که اولین عنصر به خودی خود مرتب است.
2. **مقایسه با عناصر قبلی**: عنصر فعلی با عناصر قبلی مقایسه می‌شود تا موقعیت صحیح آن مشخص شود.
3. **جابجایی عناصر**: عناصر بزرگتر از عنصر فعلی یک خانه به سمت راست جابجا می‌شوند تا فضای خالی برای قرار دادن عنصر فعلی ایجاد شود.
4. **قرار دادن عنصر در موقعیت صحیح**: عنصر فعلی در موقعیت صحیح خود قرار می‌گیرد.
5. **تکرار مراحل برای تمام عناصر**: این فرآیند برای تمام عناصر آرایه تکرار می‌شود تا آرایه به طور کامل مرتب شود.

## مزایا و معایب

**مزایا**:

- پیاده‌سازی ساده و آسان
- کارآمد برای آرایه‌های کوچک یا تقریباً مرتب
- درجا بودن (نیاز به حافظه اضافی ندارد)

**معایب**:

- زمان اجرای بالا در آرایه‌های بزرگ و نامرتب
- ناکارآمد در مقایسه با الگوریتم‌های پیچیده‌تر مثل Merge Sort یا Quick Sort برای داده‌های بزرگ

الگوریتم Insertion Sort به دلیل سادگی و کارایی مناسب در موارد خاص، همچنان یکی از الگوریتم‌های محبوب در آموزش علوم کامپیوتر و کاربردهای عملی ساده است.

## مراحل به دست آوردن مرتبه زمانی الگوریتم Insertion Sort

برای تحلیل مرتبه زمانی (Time Complexity) الگوریتم Insertion Sort، باید فرآیند اجرای آن را مرحله به مرحله بررسی کنیم و تعداد عملیات مورد نیاز در هر مرحله را محاسبه کنیم.
 **تعیین تعداد تکرارها (Iterations)** :
    - الگوریتم شامل یک حلقه تکرار خارجی است که از دومین عنصر تا آخرین عنصر آرایه اجرا می‌شود. اگر تعداد عناصر آرایه $\( n \)$ باشد، این حلقه $\( n-1 \)$ بار اجرا می‌شود.
    - بنابراین تعداد تکرارهای حلقه خارجی برابر با $\( n-1 \)$ است.

 **تعیین تعداد مقایسه‌ها و جابجایی‌ها در هر تکرار** :
    - در هر تکرار از حلقه خارجی، عنصر فعلی با عناصر قبلی مقایسه می‌شود تا موقعیت صحیح آن پیدا شود.
    - در بدترین حالت، عنصر فعلی باید با تمام عناصر قبلی مقایسه شود. بنابراین در تکرار اول یک مقایسه، در تکرار دوم دو مقایسه و ... تا تکرار $\( i \)$ ام که $\( i \)$ مقایسه انجام می‌شود.

 **محاسبه تعداد کل عملیات (مقایسه‌ها و جابجایی‌ها)** :
    - در بدترین حالت، تعداد کل عملیات (مقایسه‌ها و جابجایی‌ها) برابر با مجموع اعداد از $1$ تا $\( n-1 \)$ است.
    - مجموع این اعداد با استفاده از فرمول مجموع اعداد طبیعی محاسبه می‌شود:

$$\[ \text{Total Comparisons} = 1 + 2 + 3 + ... + (n-1) = \frac{n(n-1)}{2} \]$$

 **محاسبه مرتبه زمانی در بدترین حالت (Worst Case)** :
    - مرتبه زمانی (Time Complexity) الگوریتم Insertion Sort در بدترین حالت برابر با $\( O(n^2) \)$ است زیرا:

$$\[ T(n) = \frac{n(n-1)}{2} = \frac{n^2 - n}{2} \]$$


 **محاسبه مرتبه زمانی در بهترین حالت (Best Case)**:
    - در بهترین حالت، آرایه از قبل مرتب است و نیازی به جابجایی نیست. در این حالت، هر عنصر فقط یک بار با عنصر قبلی مقایسه می‌شود.
    - تعداد کل مقایسه‌ها در بهترین حالت برابر با $\( n-1 \)$ است، بنابراین مرتبه زمانی بهترین حالت برابر با $\( O(n) \)$ است.

### خلاصه مرتبه زمانی الگوریتم Insertion Sort

- **بدترین حالت (Worst Case)**: $\( O(n^2) \)$
- **بهترین حالت (Best Case)**: $\( O(n) \)$
- **حالت متوسط (Average Case)**: $\( O(n^2) \)$

به طور کلی، الگوریتم Insertion Sort برای آرایه‌های کوچک یا تقریباً مرتب کارآمد است، اما در مواردی که آرایه بزرگ و کاملاً نامرتب باشد، کارایی کمتری نسبت به الگوریتم‌های پیچیده‌تر مثل Merge Sort یا Quick Sort دارد.

