# :collision: الگوریتم Merge Sort

**یک الگوریتم مرتب‌سازی مبتنی بر تقسیم و حل (Divide and Conquer) است که به صورت بازگشتی(Recursive)عمل می‌کند. عملکرد این الگوریتم به این صورت است:**\
**:one:تقسیم لیست به دو نیمه تا زمانی که لیست فقط شامل یک عنصر باشد.**\
**:two:ادغام (Merge) دو نیمه به صورت مرتب شده.**\
**:three:ادامه این فرآیند برای نیمه‌ها به صورت بازگشتی تا زمانی که تمام لیست مرتب شود.**

## :question: مثال:
**فرض کنید لیستی از اعداد زیر داریم:**

**\[ 5, 3, 8, 4, 2 \]**

**1.تقسیم لیست به دو نیمه: [5, 3, 8] و [4, 2].**\
**2.تقسیم هر یک از نیمه‌ها به دو نیمه: [5, 3]، [8] و [4]، [2].**\
**3.ادغام دو نیمه مرتب شده: [3, 5] و [8]، [2, 4].**\
**4.ادغام دو نیمه اصلی: [3, 5, 8] و [2, 4].**\
**5.ادغام نهایی: [2, 3, 4, 5, 8].**\
***
## تحلیل مرتبه زمانی Merge Sort

**تقسیم (Divide):**

- در هر سطح از بازگشت، آرایه به دو نیم تقسیم می‌شود.
- این عملیات در زمان \(O(1)\) انجام می‌شود، چون فقط یک محاسبه تقسیم نیاز دارد.

**ترکیب (Combine):**

- در هر سطح از بازگشت، دو زیرآرایه مرتب شده ترکیب می‌شوند.
- این عملیات برای هر سطح از بازگشت به زمان \(O(n)\) نیاز دارد، چون باید تمام عناصر آرایه بررسی شوند.

**ارتفاع درخت بازگشتی:**

- تعداد دفعاتی که باید آرایه را نصف کنیم تا به زیرآرایه‌های تک‌عضوی برسیم، \(\log_2(n)\) است.
- بنابراین، تعداد سطوح درخت بازگشتی برابر با \(\log_2(n)\) است.

**محاسبه مرتبه زمانی کل:**

در هر سطح از بازگشت، ترکیب زیرآرایه‌ها به زمان \(O(n)\) نیاز دارد و چون تعداد سطوح درخت بازگشتی \(\log_2(n)\) است، زمان کل برابر خواهد بود با:

\[T(n) = O(n \log n)\]

بنابراین، مرتبه زمانی Merge Sort در بهترین، بدترین و حالت متوسط برابر با \(O(n \log n)\) است. این باعث می‌شود که Merge Sort یکی از الگوریتم‌های کارآمد برای مرتب‌سازی آرایه‌های بزرگ باشد.

