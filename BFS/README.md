# الگوریتم BFS (Breadth-First Search)

الگوریتم BFS (جستجوی سطح به سطح یا جستجوی پهنا) یکی از الگوریتم‌های معروف و پایه‌ای در علوم کامپیوتر است که برای پیمایش یا جستجوی ساختارهای داده‌ای مانند گراف‌ها و درخت‌ها استفاده می‌شود. این الگوریتم توسط اِدسگر دِیکسترا در سال 1959 ارائه شد.

## نحوه عملکرد الگوریتم BFS

الگوریتم BFS از یک صف (queue) برای پیگیری رأس‌ها (نودها) استفاده می‌کند و فرآیند آن به شرح زیر است:

 **شروع از رأس اولیه**:
   - الگوریتم از یک رأس شروع (source node) آغاز می‌شود. این رأس به صف افزوده شده و به عنوان بازدید شده علامت‌گذاری می‌شود.

 **پیمایش و بازدید از همسایگان**:
   - رأس جلویی صف حذف شده و تمام همسایگان آن که هنوز بازدید نشده‌اند به صف افزوده می‌شوند. این همسایگان نیز به عنوان بازدید شده علامت‌گذاری می‌شوند.

 **تکرار مراحل**:
   - مراحل 2 و 3 تکرار می‌شوند تا زمانی که صف خالی شود.

## مزایا و معایب

**مزایا**:
- ساده و قابل فهم.
- کارآمد برای گراف‌های کم‌عمق و وسیع.
- یافتن کوتاه‌ترین مسیر در گراف‌های بدون وزن.

**معایب**:
- ممکن است حافظه زیادی مصرف کند، به ویژه در گراف‌های بسیار بزرگ.
- کارایی در گراف‌های وزن‌دار محدود است (برای این موارد الگوریتم‌هایی مثل Dijkstra مناسب‌تر هستند).

الگوریتم BFS به دلیل سادگی و کارایی مناسب در بسیاری از مسائل گرافی، یکی از الگوریتم‌های محبوب و پرکاربرد در علوم کامپیوتر است.


## تحلیل مرتبه زمانی الگوریتم BFS

الگوریتم BFS یکی از الگوریتم‌های جستجو در گراف است که از نوع جستجوی سطحی است. این الگوریتم از یک صف استفاده می‌کند و به ترتیب از نودهای مجاور یک نود خاص شروع به جستجو می‌کند.

### مراحل اجرای الگوریتم BFS

 انتخاب یک نود اولیه:
   - یک نود اولیه به عنوان نقطه شروع برای جستجو انتخاب می‌شود.

 اضافه کردن نود اولیه به صف:
   - نود اولیه به صف اضافه می‌شود.

 تکرار تا زمان خالی شدن صف:
   - مادامی که صف خالی نشده است، مراحل زیر تکرار می‌شود:
     - نود بالای صف را حذف کرده و به عنوان نود جاری در نظر می‌گیریم.
     - همسایه‌های نود جاری که قبلاً بازدید نشده‌اند را به صف اضافه می‌کنیم و آن‌ها را به عنوان بازدید شده علامت می‌زنیم.

 پایان عملیات:
   - عملیات پایان می‌یابد زمانی که صف خالی شده و هیچ نود جدیدی برای بازدید وجود ندارد.

### پیچیدگی زمانی الگوریتم BFS

- مرتبه زمانی: 
  - پیچیدگی زمانی الگوریتم BFS برابر با $\(O(V + E)\)$ است، که $\(V\)$ تعداد راس‌ها و $\(E\)$ تعداد یال‌ها در گراف است.
  - زیرا در بدترین حالت، الگوریتم ممکن است همه راس‌ها و یال‌ها را چک کند.
  - به عبارت دیگر، زمان اجرای الگوریتم به طور مستقیم وابسته به اندازه و ویژگی‌های گراف است و با تعداد راس‌ها و یال‌ها افزایش می‌یابد.

### فرمول مرتبه زمانی BFS

$$\[ T(V, E) = O(V + E) \]$$

### نتیجه‌گیری

الگوریتم BFS یک الگوریتم جستجوی سطحی است که به صورت متناسب با اندازه و ویژگی‌های گراف بهینه می‌شود. مرتبه زمانی این الگوریتم به طور مستقیم وابسته به تعداد راس‌ها و یال‌ها در گراف است و در بدترین حالت برابر با $\(O(V + E)\)$ است.
