# الگوریتم Shell Sort

الگوریتم Shell Sort یکی از بهبود یافته‌های الگوریتم Insertion Sort است که توسط دونالد شل در سال 1959 ارائه شد. این الگوریتم با هدف کاهش زمان اجرای Insertion Sort برای آرایه‌های بزرگ طراحی شده است. Shell Sort این کار را با مقایسه و جابجایی عناصر که فاصله زیادی از هم دارند، انجام می‌دهد و به تدریج این فاصله را کاهش می‌دهد.

## نحوه عملکرد الگوریتم Shell Sort

### انتخاب فاصله اولیه (Gap):

- فاصله اولیه (gap) انتخاب می‌شود. این فاصله معمولاً به صورت نصف طول آرایه شروع می‌شود و به تدریج کاهش می‌یابد.
- به عنوان مثال، اگر طول آرایه \( n \) باشد، فاصله اولیه می‌تواند \( n/2 \) باشد.

### گروه‌بندی عناصر با فاصله انتخابی:

- عناصر آرایه به زیرآرایه‌هایی تقسیم می‌شوند که هر زیرآرایه شامل عناصری است که با فاصله اولیه \( gap \) از هم جدا شده‌اند.

### مرتب‌سازی هر زیرآرایه با استفاده از Insertion Sort:

- هر زیرآرایه به صورت جداگانه با استفاده از Insertion Sort مرتب می‌شود.
- این مرحله باعث می‌شود که عناصر نزدیک به جایگاه نهایی خود قرار گیرند.

### کاهش فاصله (Gap Reduction):

- فاصله (gap) به یک مقدار کوچکتر کاهش می‌یابد (معمولاً نصف می‌شود).
- مراحل 2 و 3 تکرار می‌شوند تا زمانی که فاصله به 1 برسد.

### مرحله نهایی:

- وقتی فاصله به 1 کاهش یافت، کل آرایه به طور کامل با استفاده از Insertion Sort مرتب می‌شود.

## مزایا و معایب

**مزایا**:

- کارآمدتر از Insertion Sort برای آرایه‌های بزرگ
- ساده برای پیاده‌سازی
- درجا بودن (نیاز به حافظه اضافی ندارد)

**معایب**:

- کارایی وابسته به انتخاب فاصله (gap) است
- پیچیدگی تحلیل زمانی

الگوریتم Shell Sort به دلیل سادگی و کارایی مناسب برای بسیاری از موارد عملی، همچنان یکی از الگوریتم‌های محبوب در مرتب‌سازی است.

### تحلیل مرتبه زمانی Shell Sort

مرتبه زمانی Shell Sort به شدت وابسته به دنباله فاصله‌های انتخابی است. برای دنباله فاصله‌های معمول \(\frac{n}{2}, \frac{n}{4}, \ldots, 1\) تحلیل کلی به شرح زیر است:

 تعداد مراحل (Stages):
   - اگر دنباله فاصله‌ها را \(h_1, h_2, \ldots, h_k\) در نظر بگیریم، تعداد مراحل برابر با \(k\) خواهد بود.

 مرتب‌سازی با فاصله مشخص:
   - هر مرحله از الگوریتم نیازمند مرتب‌سازی عناصر با فاصله \(h_i\) است که با استفاده از Insertion Sort انجام می‌شود.

 تحلیل هر مرحله:
   - در مرحله‌ای با فاصله \(h_i\)، مجموعه‌ای از زیرآرایه‌ها به طول \(\frac{n}{h_i}\) وجود دارد. هر کدام از این زیرآرایه‌ها به صورت مستقل با استفاده از Insertion Sort مرتب می‌شوند.
   - پیچیدگی زمانی Insertion Sort برای یک زیرآرایه به طول \(m\) برابر با \(O(m^2)\) است.

 پیچیدگی زمانی کل:
   - برای دنباله فاصله‌های $\(\frac{n}{2}, \frac{n}{4}, \ldots, 1\)$ پیچیدگی زمانی کل $\(T(n)\)$ برابر است با:
     $$\[
     T(n) = \sum_{i=1}^{k} O\left(\frac{n}{h_i} \cdot h_i^2\right) = \sum_{i=1}^{k} O(n h_i)
     \]$$

### انتخاب دنباله‌های مختلف و پیچیدگی زمانی

- دنباله فاصله $\( \frac{n}{2}, \frac{n}{4}, \ldots, 1 \)$:
  - پیچیدگی زمانی به طور کلی $\(O(n^2)\)$ است.

- دنباله‌های بهینه‌تر (مانند دنباله Knuth):
  - در دنباله $Knuth: \(1, 4, 13, 40, \ldots, 3k + 1\)$:
  - پیچیدگی زمانی حدودی $\(O(n^{3/2})\)$ است.

- دنباله Hibbard:
  - در دنباله $Hibbard: \(1, 3, 7, 15, \ldots, 2^k - 1\)$:
  - پیچیدگی زمانی حدودی $\(O(n^{3/2})\)$ است.

### نتیجه‌گیری

مرتبه زمانی Shell Sort به دنباله فاصله‌های انتخابی وابسته است. برای دنباله‌های ساده‌تر مانند $\(\frac{n}{2}, \frac{n}{4}, \ldots, 1\)$ پیچیدگی زمانی حدود $\(O(n^2)\)$ است، در حالی که دنباله‌های بهینه‌تر مانند Knuth و Hibbard می‌توانند پیچیدگی زمانی را به حدود $\(O(n^{3/2})\)$ کاهش دهند. در بدترین حالت، پیچیدگی زمانی برای برخی دنباله‌ها می‌تواند به $\(O(n \log^2 n)\)$ نزدیک شود.
