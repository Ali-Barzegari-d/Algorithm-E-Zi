# :collision: الگوریتم Binary Search(سرچ دودویی)


**یکی از موثرترین روش‌های جستجو در یک لیست مرتب است. عملکرد آن به این شکل است:**

**:one:مقایسه عنصر میانی لیست با عنصر مورد نظر.**\
**:two:اگر عنصر میانی برابر با عنصر مورد نظر باشد، جستجو پایان می‌یابد.**\
**:three:اگر عنصر میانی بزرگ‌تر از عنصر مورد نظر باشد، جستجو در نیمه‌ای که عنصر میانی در آن قرار دارد ادامه می‌یابد.**\
**:four:اگر عنصر میانی کوچک‌تر از عنصر مورد نظر باشد، جستجو در نیمه‌ای که عنصر میانی در آن قرار دارد ادامه می‌یابد.**\
**:five:این فرآیند تا زمانی ادامه می‌یابد که عنصر مورد نظر پیدا شود یا لیست تماماً جستجو شود.**

## :question: مثال:

**فرض کنید لیستی از اعداد زیر داریم:**

**[2,4,6,8,10,12,14,16]**

**حالا بیایید فرض کنیم ما می‌خواهیم عدد 10 را جستجو کنیم.**

**مراحل جستجو به این شکل است:**

**1. میانه لیست را پیدا می‌کنیم.برای پیدا کردن میانه از فرمول زیر استفاده میکنیم:**
$$\lfloor \frac{n}{2} \rfloor$$
**در این لیست، میانه(mid) این است که یعنی عنصر در موقعیت چهارم است که مقدارش 8 است.**
  
**[2,4,6, :eight: ,10,12,14,16]**


**2. از آنجا که 10 بزرگ‌تر از 8 است، ما باید در نیمه‌ی بعدی ادامه دهیم.**\
**3. حالا لیست به این شکل است:**

**[10,12,14,16]**

**میانه(mid)جدید ما در این مرحله برابر با 14 است.**

**[10,12, :one::four: ,16]**

**4. 10 کوچک‌تر از 14 است، بنابراین ما باید در نیمه‌ی اولیه ادامه دهیم.**\
**5. لیست به این شکل می‌شود:**\
**[10,12]**
**میانه(mid)جدید ما در این مرحله برابر با 12 است.**

**[10,12, :one::two: ,16]**

**6.اکنون، 10 کوچک‌تر از 12 است ولی اینجا دیگر نمی‌توانیم نیمه‌ها را تقسیم کنیم.**\
**ما عدد 10 را پیدا کردیم.**
 ***
 ## مرتبه زمانی :rabbit2: Or :snail:
**با فرض اینکه لیست دارای ( n ) عنصر باشد، الگوریتم جستجوی دودویی به طور معمول در مرتبه زمانی O(log n) اجرا می‌شود.**


